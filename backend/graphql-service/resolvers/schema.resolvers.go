package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"ecopoint-backend/graphql-service/generated"
	"ecopoint-backend/graphql-service/middleware"
	"ecopoint-backend/shared/models"
	pb_auth "ecopoint-backend/proto"
	pb_order "ecopoint-backend/proto"
	pb_user "ecopoint-backend/proto"
	"fmt"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// GoogleSignIn is the resolver for the googleSignIn field.
func (r *mutationResolver) GoogleSignIn(ctx context.Context, input generated.GoogleSignInInput) (*generated.AuthPayload, error) {
	// Convert GraphQL input to gRPC request
	userType := pb_user.UserType_USER_TYPE_CUSTOMER
	if input.UserType == models.UserTypeCollector {
		userType = pb_user.UserType_USER_TYPE_COLLECTOR
	}

	req := &pb_auth.GoogleSignInRequest{
		IdToken:  input.IDToken,
		UserType: userType,
	}

	// Call gRPC Auth Service
	resp, err := r.GRPCClients.AuthClient.GoogleSignIn(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("authentication failed: %v", err)
	}

	// Convert gRPC response to GraphQL
	user := convertProtoUserToModel(resp.User)
	
	return &generated.AuthPayload{
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		User:         user,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*generated.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input generated.UpdateProfileInput) (*models.User, error) {
	panic(fmt.Errorf("not implemented: UpdateProfile - updateProfile"))
}

// SetCollectorOnlineStatus is the resolver for the setCollectorOnlineStatus field.
func (r *mutationResolver) SetCollectorOnlineStatus(ctx context.Context, isOnline bool) (*models.User, error) {
	panic(fmt.Errorf("not implemented: SetCollectorOnlineStatus - setCollectorOnlineStatus"))
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input generated.CreateOrderInput) (*models.Order, error) {
	// Require authentication
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Convert waste types  
	pbWasteTypes := convertWasteTypesToProto(input.WasteTypes)

	// Create gRPC request
	req := &pb_order.CreateOrderRequest{
		CustomerId:      user.UID,
		WasteTypes:      pbWasteTypes,
		EstimatedWeight: input.EstimatedWeight,
		PickupAddress: &pb_order.Address{
			Street:   input.PickupAddress.Street,
			District: input.PickupAddress.District,
			City:     input.PickupAddress.City,
			Lat:      input.PickupAddress.Lat,
			Lng:      input.PickupAddress.Lng,
		},
		ScheduledTime: timestamppb.New(input.ScheduledTime),
		Notes:         *input.Notes,
	}

	// Call gRPC Order Service
	resp, err := r.GRPCClients.OrderClient.CreateOrder(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %v", err)
	}

	return convertProtoOrderToModel(resp.Order), nil
}

// AcceptOrder is the resolver for the acceptOrder field.
func (r *mutationResolver) AcceptOrder(ctx context.Context, orderID string) (*models.Order, error) {
	panic(fmt.Errorf("not implemented: AcceptOrder - acceptOrder"))
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status models.OrderStatus) (*models.Order, error) {
	panic(fmt.Errorf("not implemented: UpdateOrderStatus - updateOrderStatus"))
}

// CompleteOrder is the resolver for the completeOrder field.
func (r *mutationResolver) CompleteOrder(ctx context.Context, orderID string, input generated.CompleteOrderInput) (*models.Order, error) {
	panic(fmt.Errorf("not implemented: CompleteOrder - completeOrder"))
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, orderID string) (*models.Order, error) {
	panic(fmt.Errorf("not implemented: CancelOrder - cancelOrder"))
}

// ID is the resolver for the id field.
func (r *orderResolver) ID(ctx context.Context, obj *models.Order) (string, error) {
	return obj.ID.Hex(), nil
}

// CustomerID is the resolver for the customerID field.
func (r *orderResolver) CustomerID(ctx context.Context, obj *models.Order) (string, error) {
	panic(fmt.Errorf("not implemented: CustomerID - customerID"))
}

// CollectorID is the resolver for the collectorID field.
func (r *orderResolver) CollectorID(ctx context.Context, obj *models.Order) (*string, error) {
	panic(fmt.Errorf("not implemented: CollectorID - collectorID"))
}

// Customer is the resolver for the customer field.
func (r *orderResolver) Customer(ctx context.Context, obj *models.Order) (*models.User, error) {
	// TODO: Implement customer lookup via gRPC
	return nil, nil
}

// Collector is the resolver for the collector field.
func (r *orderResolver) Collector(ctx context.Context, obj *models.Order) (*models.User, error) {
	// TODO: Implement collector lookup via gRPC
	return nil, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	// Require authentication
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Get user profile from gRPC service
	req := &pb_auth.GetProfileRequest{
		UserId: user.UID,
	}

	resp, err := r.GRPCClients.AuthClient.GetProfile(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get user profile: %v", err)
	}

	return convertProtoUserToModel(resp.User), nil
}

// UserStats is the resolver for the userStats field.
func (r *queryResolver) UserStats(ctx context.Context) (*generated.UserStats, error) {
	panic(fmt.Errorf("not implemented: UserStats - userStats"))
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*models.Order, error) {
	// Require authentication
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Determine user type for the request
	userType := "customer"
	// TODO: Get actual user type from user profile

	req := &pb_order.GetUserOrdersRequest{
		UserId:   user.UID,
		UserType: userType,
	}

	resp, err := r.GRPCClients.OrderClient.GetUserOrders(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %v", err)
	}

	orders := make([]*models.Order, len(resp.Orders))
	for i, pbOrder := range resp.Orders {
		orders[i] = convertProtoOrderToModel(pbOrder)
	}

	return orders, nil
}

// AvailableOrders is the resolver for the availableOrders field.
func (r *queryResolver) AvailableOrders(ctx context.Context) ([]*models.Order, error) {
	// Require authentication
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	req := &pb_order.GetAvailableOrdersRequest{
		CollectorId: user.UID,
	}

	resp, err := r.GRPCClients.OrderClient.GetAvailableOrders(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get available orders: %v", err)
	}

	orders := make([]*models.Order, len(resp.Orders))
	for i, pbOrder := range resp.Orders {
		orders[i] = convertProtoOrderToModel(pbOrder)
	}

	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*models.Order, error) {
	panic(fmt.Errorf("not implemented: Order - order"))
}

// OrderUpdated is the resolver for the orderUpdated field.
func (r *subscriptionResolver) OrderUpdated(ctx context.Context, orderID string) (<-chan *models.Order, error) {
	panic(fmt.Errorf("not implemented: OrderUpdated - orderUpdated"))
}

// NewOrderAvailable is the resolver for the newOrderAvailable field.
func (r *subscriptionResolver) NewOrderAvailable(ctx context.Context) (<-chan *models.Order, error) {
	panic(fmt.Errorf("not implemented: NewOrderAvailable - newOrderAvailable"))
}

// MyOrderUpdated is the resolver for the myOrderUpdated field.
func (r *subscriptionResolver) MyOrderUpdated(ctx context.Context) (<-chan *models.Order, error) {
	panic(fmt.Errorf("not implemented: MyOrderUpdated - myOrderUpdated"))
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return obj.ID.Hex(), nil
}

// Address is the resolver for the address field.
func (r *userResolver) Address(ctx context.Context, obj *models.User) (*models.Address, error) {
	// Address is not part of base User model in current setup
	// Return nil for now
	return nil, nil
}

// Vehicle is the resolver for the vehicle field.
func (r *userResolver) Vehicle(ctx context.Context, obj *models.User) (*models.Vehicle, error) {
	// Vehicle is not part of base User model in current setup
	// Return nil for now
	return nil, nil
}

// Rating is the resolver for the rating field.
func (r *userResolver) Rating(ctx context.Context, obj *models.User) (*float64, error) {
	panic(fmt.Errorf("not implemented: Rating - rating"))
}

// IsOnline is the resolver for the isOnline field.
func (r *userResolver) IsOnline(ctx context.Context, obj *models.User) (*bool, error) {
	panic(fmt.Errorf("not implemented: IsOnline - isOnline"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver { return &orderResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
